// Copyright 2022 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/webui/side_panel/customize_chrome/customize_chrome_page_handler.h"

#include "base/metrics/histogram_functions.h"
#include "base/metrics/histogram_macros.h"
#include "chrome/browser/new_tab_page/chrome_colors/chrome_colors_factory.h"
#include "chrome/browser/new_tab_page/chrome_colors/chrome_colors_service.h"
#include "chrome/browser/new_tab_page/chrome_colors/selected_colors_info.h"
#include "chrome/browser/profiles/profile.h"
#include "chrome/browser/search/background/ntp_background_service_factory.h"
#include "chrome/browser/themes/theme_service.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/ui/browser_window.h"
#include "chrome/browser/ui/color/chrome_color_id.h"
#include "chrome/browser/ui/webui/new_tab_page/ntp_pref_names.h"
#include "chrome/browser/ui/webui/side_panel/customize_chrome/customize_chrome_colors.h"
#include "chrome/common/themes/autogenerated_theme_util.h"
#include "components/prefs/pref_service.h"
#include "content/public/browser/web_contents.h"
#include "mojo/public/cpp/bindings/pending_remote.h"
#include "ui/base/l10n/l10n_util.h"
#include "ui/color/color_provider.h"
#include "ui/native_theme/native_theme.h"

CustomizeChromePageHandler::CustomizeChromePageHandler(
    mojo::PendingReceiver<side_panel::mojom::CustomizeChromePageHandler>
        pending_page_handler,
    mojo::PendingRemote<side_panel::mojom::CustomizeChromePage> pending_page,
    NtpCustomBackgroundService* ntp_custom_background_service,
    content::WebContents* web_contents)
    : ntp_custom_background_service_(ntp_custom_background_service),
      profile_(Profile::FromBrowserContext(web_contents->GetBrowserContext())),
      web_contents_(web_contents),
      ntp_background_service_(
          NtpBackgroundServiceFactory::GetForProfile(profile_)),
      theme_service_(ThemeServiceFactory::GetForProfile(profile_)),
      page_(std::move(pending_page)),
      receiver_(this, std::move(pending_page_handler)) {
  CHECK(ntp_custom_background_service_);
  CHECK(theme_service_);
  CHECK(ntp_background_service_);
  ntp_background_service_->AddObserver(this);
  native_theme_observation_.Observe(ui::NativeTheme::GetInstanceForNativeUi());
  theme_service_observation_.Observe(theme_service_);
}

CustomizeChromePageHandler::~CustomizeChromePageHandler() {
  ntp_background_service_->RemoveObserver(this);
}

void CustomizeChromePageHandler::SetMostVisitedSettings(
    bool custom_links_enabled,
    bool visible) {
  if (IsShortcutsVisible() != visible)
    profile_->GetPrefs()->SetBoolean(ntp_prefs::kNtpShortcutsVisible, visible);

  if (IsCustomLinksEnabled() != custom_links_enabled) {
    profile_->GetPrefs()->SetBoolean(ntp_prefs::kNtpUseMostVisitedTiles,
                                     !custom_links_enabled);
  }
}

void CustomizeChromePageHandler::GetMostVisitedSettings(
    GetMostVisitedSettingsCallback callback) {
  std::move(callback).Run(IsCustomLinksEnabled(), IsShortcutsVisible());
}

void CustomizeChromePageHandler::GetChromeColors(
    GetChromeColorsCallback callback) {
  std::vector<side_panel::mojom::ChromeColorPtr> colors;
  for (const auto& color_info : kCustomizeChromeColors) {
    auto theme_colors = GetAutogeneratedThemeColors(color_info.color);
    auto color = side_panel::mojom::ChromeColor::New();
    color->name = l10n_util::GetStringUTF8(color_info.label_id);
    color->background = theme_colors.active_tab_color;
    color->foreground = theme_colors.frame_color;
    colors.push_back(std::move(color));
  }
  std::move(callback).Run(std::move(colors));
}

void CustomizeChromePageHandler::GetBackgroundCollections(
    GetBackgroundCollectionsCallback callback) {
  if (!ntp_background_service_ || background_collections_callback_) {
    std::move(callback).Run(
        std::vector<side_panel::mojom::BackgroundCollectionPtr>());
    return;
  }
  background_collections_request_start_time_ = base::TimeTicks::Now();
  background_collections_callback_ = std::move(callback);
  ntp_background_service_->FetchCollectionInfo();
}

void CustomizeChromePageHandler::UpdateTheme() {
  auto theme = side_panel::mojom::Theme::New();
  auto custom_background =
      ntp_custom_background_service_
          ? ntp_custom_background_service_->GetCustomBackground()
          : absl::nullopt;
  auto background_image = side_panel::mojom::BackgroundImage::New();
  if (custom_background.has_value()) {
    background_image->url = custom_background->custom_background_url;
    background_image->is_uploaded_image = custom_background->is_uploaded_image;
    background_image->title =
        custom_background->custom_background_attribution_line_1;
  } else {
    background_image = nullptr;
  }
  theme->background_image = std::move(background_image);
  theme->background_color =
      web_contents_->GetColorProvider().GetColor(kColorNewTabPageBackground);
  if (!theme_service_->UsingDefaultTheme() &&
      !theme_service_->UsingSystemTheme()) {
    theme->foreground_color =
        web_contents_->GetColorProvider().GetColor(ui::kColorFrameActive);
  }
  theme->color_picker_icon_color =
      web_contents_->GetColorProvider().GetColor(kColorNewTabPageText);
  auto* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
  CHECK(native_theme);
  theme->system_dark_mode = native_theme->ShouldUseDarkColors();
  page_->SetTheme(std::move(theme));
}

void CustomizeChromePageHandler::SetDefaultColor() {
  theme_service_->UseDefaultTheme();
}

void CustomizeChromePageHandler::SetForegroundColor(SkColor foreground_color) {
  theme_service_->BuildAutogeneratedThemeFromColor(foreground_color);
}

void CustomizeChromePageHandler::SetClassicChromeDefaultTheme() {
  ntp_custom_background_service_->ResetCustomBackgroundInfo();
  theme_service_->UseDefaultTheme();
}

void CustomizeChromePageHandler::OnNativeThemeUpdated(
    ui::NativeTheme* observed_theme) {
  UpdateTheme();
}

void CustomizeChromePageHandler::OnThemeChanged() {
  UpdateTheme();
}

bool CustomizeChromePageHandler::IsCustomLinksEnabled() const {
  return !profile_->GetPrefs()->GetBoolean(ntp_prefs::kNtpUseMostVisitedTiles);
}

bool CustomizeChromePageHandler::IsShortcutsVisible() const {
  return profile_->GetPrefs()->GetBoolean(ntp_prefs::kNtpShortcutsVisible);
}

void CustomizeChromePageHandler::OnCollectionInfoAvailable() {
  if (!background_collections_callback_) {
    return;
  }

  base::TimeDelta duration =
      base::TimeTicks::Now() - background_collections_request_start_time_;
  UMA_HISTOGRAM_MEDIUM_TIMES(
      "NewTabPage.BackgroundService.Collections.RequestLatency", duration);
  // Any response where no collections are returned is considered a failure.
  if (ntp_background_service_->collection_info().empty()) {
    UMA_HISTOGRAM_MEDIUM_TIMES(
        "NewTabPage.BackgroundService.Collections.RequestLatency.Failure",
        duration);
  } else {
    UMA_HISTOGRAM_MEDIUM_TIMES(
        "NewTabPage.BackgroundService.Collections.RequestLatency.Success",
        duration);
  }

  std::vector<side_panel::mojom::BackgroundCollectionPtr> collections;
  for (const auto& info : ntp_background_service_->collection_info()) {
    auto collection = side_panel::mojom::BackgroundCollection::New();
    collection->id = info.collection_id;
    collection->label = info.collection_name;
    collection->preview_image_url = GURL(info.preview_image_url);
    collections.push_back(std::move(collection));
  }
  std::move(background_collections_callback_).Run(std::move(collections));
}

void CustomizeChromePageHandler::OnCollectionImagesAvailable() {}

void CustomizeChromePageHandler::OnNextCollectionImageAvailable() {}

void CustomizeChromePageHandler::OnNtpBackgroundServiceShuttingDown() {
  ntp_background_service_->RemoveObserver(this);
  ntp_background_service_ = nullptr;
}
