<!DOCTYPE html>
<title>window.fence.getNestedConfigs() test</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/utils.js"></script>
<script src="/common/utils.js"></script>
<script src="/common/get-host-info.sub.js"></script>

<body>
<script>
promise_test(async (t) => {
  const key = token();
  const urn = await generateURNFromFledge(
      "resources/get-nested-configs-inner.html", [key]);
  attachFencedFrame(urn, mode='opaque-ads');

  const response = await nextValueFromServer(key);
  const [length, first_url] = response.split(",");

  assert_equals(length, '20', 'There should be 20 nested configurations.');
  assert_equals(first_url, 'opaque', 'The first config should be opaque.');
}, 'getNestedConfigs() created by FLEDGE should return configurations');

promise_test(async (t) => {
  const key = token();
  const urn = await generateURN(
      generateURL("resources/get-nested-configs-inner.html", [key]));
  attachFencedFrame(urn, mode='opaque-ads');

  const response = await nextValueFromServer(key);
  const [length, first_url] = response.split(",");

  assert_equals(length, '0', 'There should be 0 nested configurations.');
}, 'getNestedConfigs() from a non-FLEDGE URN frame should be empty');

promise_test(async (t) => {
  const key = token();
  const url = generateURL("resources/get-nested-configs-inner.html", [key]);
  attachFencedFrame(url, mode='default');

  const response = await nextValueFromServer(key);
  const [length, first_url] = response.split(",");

  assert_equals(length, '0', 'There should be 0 nested configurations.');
}, 'getNestedConfigs() from a default mode frame should be empty');

promise_test(async (t) => {
  const key = token();
  const urn = await generateURNFromFledge(
      "resources/get-nested-configs-nested-iframe.html", [key]);
  attachFencedFrame(urn, mode='opaque-ads');

  const response = await nextValueFromServer(key);
  const [length, first_url] = response.split(",");

  assert_equals(length, '0', 'There should be 0 nested configurations.');
}, 'getNestedConfigs() in a nested iframe should be empty');

promise_test(async (t) => {
  const key = token();

  const nested_url = generateURL("resources/embeddee.html", [key]);

  // Navigate a fenced frame to `navigate-nested-config.html`. That page will
  // in turn create a nested fenced frame which will be navigated to the URN of
  // the first item in the nested configs list, `nested_url`.
  const urn = await generateURNFromFledge(
      "resources/navigate-nested-config.html", [key],
      [nested_url]);
  attachFencedFrame(urn, mode='opaque-ads');

  const response = await nextValueFromServer(key);
  assert_equals(response, 'PASS', 'The nested URL should load.');
}, 'Nested configs created by FLEDGE should be navigable');

promise_test(async (t) => {
  const key = token();

  const nested_url = generateURL("resources/embeddee.html", [key]);

  // Navigate a fenced frame to `navigate-nested-config.html`. That page will
  // in turn create a nested fenced frame which will be navigated to the URN of
  // the first item in the nested configs list, `nested_url`. Since this URN
  // is invalid, the navigation should gracefully fail.
  const urn = await generateURNFromFledge(
      "resources/navigate-nested-config.html", [key],
      []);
  attachFencedFrame(urn, mode='opaque-ads');

  // There is no API to observe whether the document in the FencedFrame loaded
  // or not. Instead, set up a timeout. If the document loads, "PASS" will be
  // sent to the server. Otherwise "BLOCKED" will be sent after 1 second.
  step_timeout(() => {
    writeValueToServer(key, "BLOCKED");
  }, 1000);

  const response = await nextValueFromServer(key);
  assert_equals(response, 'BLOCKED', 'The nested URL should not load.');
}, 'Navigating an invalid config should be handled gracefully');

</script>
</body>
</html>
